# Maintainability Rules - AI Assistant Custom Instructions

## Purpose

This directory contains SonarQube rules focused on **maintainability concerns**. These rules detect patterns that make code harder to understand, modify, test, and extend over time. While these issues don't cause immediate bugs, they increase technical debt and slow down development velocity.

---

## Rules in This Category (7 Rules)

| Rule File | Key | Description |
|-----------|-----|-------------|
| `deep-nesting.json` | `deep-nesting` | Excessive nesting levels (if/loop/try depth) |
| `hardcoded-urls.json` | `hardcoded-urls` | URLs/endpoints that should be externalized |
| `inconsistent-naming.json` | `inconsistent-naming` | Naming convention violations |
| `long-methods.json` | `long-methods` | Methods exceeding length thresholds |
| `missing-javadoc.json` | `missing-javadoc` | Public APIs lacking documentation |
| `missing-null-check.json` | `missing-null-check` | Potential null pointer dereferences |
| `too-many-parameters.json` | `too-many-parameters` | Excessive method parameters |

---

## Maintainability Rule Requirements

### Mandatory Properties

All maintainability rules in this directory MUST have:

```json
{
  "type": "CODE_SMELL",
  "severity": "MAJOR" or "MINOR",
  "tags": ["maintainability", ...]
}
```

### Exception: missing-null-check

The `missing-null-check` rule may use:
```json
{
  "type": "BUG",
  "severity": "MAJOR"
}
```
Because null pointer dereferences cause runtime failures.

### Severity Guidelines for Maintainability Rules

| Severity | When to Use | Examples |
|----------|-------------|----------|
| `MAJOR` | Significantly impacts code comprehension or modification | Long methods, deep nesting, missing documentation |
| `MINOR` | Lower-impact, often style/convention based | Naming conventions, hardcoded URLs |

---

## Required Tags

Always include these tags where applicable:

| Tag | When to Include |
|-----|-----------------|
| `maintainability` | **Always** - all rules in this directory |
| `readability` | Impacts code comprehension |
| `complexity` | Cognitive or structural complexity |
| `documentation` | Documentation-related issues |
| `naming` | Naming convention issues |
| `refactoring` | Suggests refactoring needed |
| `configuration` | Externalization/configuration issues |
| `method-length` | Method size issues |

---

## Creating New Maintainability Rules

### Template

```json
{
  "key": "maintainability-issue",
  "name": "Maintainability Issue Name",
  "description": "Detects [specific pattern] which makes the code [specific maintainability impact]. This increases cognitive load and [additional impact].",
  "severity": "MAJOR",
  "type": "CODE_SMELL",
  "tags": ["maintainability", "readability"],
  "remediation": {
    "constantCost": "15min",
    "examples": [
      {
        "before": "// Hard to maintain code",
        "after": "// Easier to maintain code"
      }
    ]
  },
  "impacts": [
    {
      "softwareQuality": "MAINTAINABILITY",
      "severity": "MEDIUM"
    }
  ],
  "defaultSeverity": "MAJOR",
  "status": "READY",
  "debt": {
    "function": "CONSTANT_ISSUE",
    "offset": "15min"
  }
}
```

### Template with Configurable Thresholds

Many maintainability rules have configurable limits:

```json
{
  "key": "threshold-rule",
  "name": "Threshold-Based Rule",
  "description": "Detects when [metric] exceeds acceptable limits for maintainability.",
  "severity": "MAJOR",
  "type": "CODE_SMELL",
  "tags": ["maintainability", "complexity"],
  "debt": {
    "function": "LINEAR",
    "coefficient": "5min",
    "offset": "0min"
  },
  "params": [
    {
      "key": "max",
      "name": "Maximum Allowed",
      "description": "Maximum allowed value before flagging",
      "defaultValue": "50",
      "type": "INTEGER"
    }
  ]
}
```

### Checklist for New Maintainability Rules

- [ ] `type` is `CODE_SMELL` (or `BUG` for null-safety issues)
- [ ] `severity` is `MAJOR` or `MINOR`
- [ ] `tags` includes `maintainability`
- [ ] Description explains impact on code comprehension and modification
- [ ] Consider configurable `params` for threshold-based rules
- [ ] Use `LINEAR` debt function if fix time scales with issue scope
- [ ] `impacts.softwareQuality` is `MAINTAINABILITY`

---

## Maintainability Dimensions

### Readability

**Rules:** `deep-nesting`, `long-methods`, `inconsistent-naming`

Focus: How easy is the code to understand on first read?

- Clear structure
- Consistent conventions
- Appropriate method size
- Limited nesting depth

### Modifiability

**Rules:** `long-methods`, `deep-nesting`, `hardcoded-urls`

Focus: How easy is the code to change safely?

- Small, focused units
- Externalized configuration
- Low coupling

### Documentability

**Rules:** `missing-javadoc`

Focus: How well is the code documented?

- Public API documentation
- Clear method contracts
- Usage examples

### Reliability

**Rules:** `missing-null-check`

Focus: How robust is the code against edge cases?

- Defensive programming
- Null safety
- Input validation

---

## Writing Effective Maintainability Rule Descriptions

Maintainability descriptions should explain:

1. **What is detected?** - The specific pattern
2. **Why is it a problem?** - Impact on maintainability
3. **Who is affected?** - Future developers, code reviewers
4. **How to fix?** - Refactoring approach

### Example Description

> "Detects methods or functions that exceed a reasonable length threshold, making them harder to understand and maintain. Long methods should be refactored into smaller, focused units that each do one thing well."

---

## Cognitive Complexity Considerations

When defining maintainability rules, consider cognitive load:

| Factor | Impact | Examples |
|--------|--------|----------|
| Nesting depth | High | Each level increases mental stack |
| Method length | Medium | More code = more to remember |
| Parameter count | Medium | More inputs = more combinations |
| Naming clarity | High | Poor names require constant lookup |
| Documentation | Medium | Missing docs require code reading |

---

## Remediation Time Estimates

| Maintainability Issue | Typical Remediation Time |
|----------------------|-------------------------|
| Inconsistent naming | 5min (rename with IDE refactoring) |
| Hardcoded URLs | 10min (externalize to configuration) |
| Missing Javadoc | 10min (write documentation) |
| Too many parameters | 15min (introduce parameter object) |
| Missing null check | 15min (add defensive checks) |
| Long methods | 20min (extract methods) |
| Deep nesting | 20min (use early returns, extract) |

---

## Threshold Recommendations

| Rule | Recommended Default | Industry Range |
|------|--------------------:|---------------:|
| Method length | 100 lines | 50-150 lines |
| Nesting depth | 4 levels | 3-5 levels |
| Parameter count | 5 params | 4-7 params |
| Class length | 500 lines | 300-1000 lines |
| Cyclomatic complexity | 10 | 8-15 |

---

## Common Refactoring Patterns for Maintainability

| Issue | Refactoring Pattern |
|-------|---------------------|
| Long methods | Extract Method |
| Deep nesting | Replace Nested Conditional with Guard Clauses |
| Too many parameters | Introduce Parameter Object |
| Hardcoded values | Extract to Configuration |
| Inconsistent naming | Rename (with IDE support) |
| Missing documentation | Add Javadoc/docstrings |
| Missing null check | Add Optional or null guards |

---

## Configuration vs Code

Rules like `hardcoded-urls` enforce separation of concerns:

| Should Be in Config | Can Stay in Code |
|--------------------|------------------|
| API endpoints | Internal constants |
| Database URLs | Mathematical constants |
| Feature flags | Enum values |
| Timeouts | Array indices |
| Credentials | Default values (if appropriate) |
