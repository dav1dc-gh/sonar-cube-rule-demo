# Performance Rules - AI Assistant Custom Instructions

## Purpose

This directory contains SonarQube rules focused on **performance issues**. These rules detect code patterns that cause runtime inefficiencies, excessive resource consumption, memory problems, or degraded application responsiveness. Performance rules help identify bottlenecks before they impact production systems.

---

## Rules in This Category (7 Rules)

| Rule File | Key | Description |
|-----------|-----|-------------|
| `inefficient-collection-usage.json` | `inefficient-collection-usage` | Improper collection types, missing initial capacity |
| `inefficient-loops.json` | `inefficient-loops` | Loop performance anti-patterns |
| `memory-leaks.json` | `memory-leaks` | Unclosed resources, leaked references |
| `n-plus-one-query.json` | `n-plus-one-query` | Database queries inside loops |
| `string-concatenation-in-loop.json` | `string-concatenation-in-loop` | String `+` operator in loops |
| `synchronous-io-in-async.json` | `synchronous-io-in-async` | Blocking I/O in async contexts |
| `unnecessary-boxing.json` | `unnecessary-boxing` | Primitive/wrapper boxing overhead |

---

## Performance Rule Requirements

### Mandatory Properties

Performance rules can be either `BUG` or `CODE_SMELL` depending on severity:

```json
{
  "type": "BUG" or "CODE_SMELL",
  "severity": "CRITICAL" or "MAJOR",
  "tags": ["performance", ...]
}
```

### Type Guidelines for Performance Rules

| Type | When to Use | Examples |
|------|-------------|----------|
| `BUG` | Will cause runtime failures or severe degradation | Memory leaks, resource exhaustion |
| `CODE_SMELL` | Causes inefficiency but won't crash the system | String concatenation in loop, N+1 queries |

### Severity Guidelines for Performance Rules

| Severity | When to Use | Examples |
|----------|-------------|----------|
| `CRITICAL` | Can cause system crashes, OOM, or severe degradation | Memory leaks, blocking I/O in async |
| `MAJOR` | Noticeable performance impact at scale | N+1 queries, string concatenation in loops |

---

## Required Tags

Always include these tags where applicable:

| Tag | When to Include |
|-----|-----------------|
| `performance` | **Always** - all rules in this directory |
| `memory` | Memory consumption issues |
| `database` | Database-related performance |
| `optimization` | General optimization suggestions |
| `resource-management` | Resource handling issues |
| `strings` | String handling performance |
| `collections` | Collection usage issues |
| `concurrency` | Threading/async performance |
| `orm` | ORM-related performance (N+1, lazy loading) |

---

## Creating New Performance Rules

### Template

```json
{
  "key": "performance-issue-name",
  "name": "Performance Issue Description",
  "description": "Detects [specific pattern] which causes [specific performance impact]. This can lead to [scalability concern] especially under [conditions].",
  "severity": "MAJOR",
  "type": "CODE_SMELL",
  "tags": ["performance", "optimization"],
  "remediation": {
    "constantCost": "20min",
    "examples": [
      {
        "before": "// Inefficient code pattern",
        "after": "// Optimized implementation"
      }
    ]
  },
  "impacts": [
    {
      "softwareQuality": "MAINTAINABILITY",
      "severity": "MEDIUM"
    }
  ],
  "defaultSeverity": "MAJOR",
  "status": "READY",
  "debt": {
    "function": "CONSTANT_ISSUE",
    "offset": "20min"
  }
}
```

### Template for Memory-Related Rules

```json
{
  "key": "memory-issue",
  "name": "Memory Issue Detection",
  "description": "Identifies patterns that may lead to [memory issue type].",
  "severity": "CRITICAL",
  "type": "BUG",
  "tags": ["performance", "memory", "resource-management"],
  "impacts": [
    {
      "softwareQuality": "RELIABILITY",
      "severity": "HIGH"
    }
  ]
}
```

### Checklist for New Performance Rules

- [ ] `type` is `BUG` (for critical issues) or `CODE_SMELL` (for inefficiencies)
- [ ] `severity` matches the performance impact
- [ ] `tags` includes `performance`
- [ ] Description explains the performance impact quantitatively if possible
- [ ] Remediation shows the optimized alternative
- [ ] Consider if impact is on `RELIABILITY` (crashes) or `MAINTAINABILITY` (slowness)

---

## Performance Impact Categories

### Memory Issues

**Rules:** `memory-leaks`, `inefficient-collection-usage`, `unnecessary-boxing`

Characteristics:
- Can cause `OutOfMemoryError`
- Impact increases over time or with scale
- Often invisible until production
- Type: Usually `BUG` with `CRITICAL` severity

### CPU/Algorithmic Issues

**Rules:** `inefficient-loops`, `string-concatenation-in-loop`

Characteristics:
- Unnecessary CPU cycles
- O(n²) or worse complexity
- Scales poorly with input size
- Type: Usually `CODE_SMELL` with `MAJOR` severity

### I/O Issues

**Rules:** `synchronous-io-in-async`, `n-plus-one-query`

Characteristics:
- Blocks threads unnecessarily
- Causes latency spikes
- Database/network bottlenecks
- Type: `CODE_SMELL` or `BUG` depending on context

---

## Writing Effective Performance Rule Descriptions

Performance descriptions should include:

1. **What is detected?** - The inefficient pattern
2. **Why is it slow?** - Technical explanation
3. **What's the impact?** - Quantified if possible (e.g., "O(n²) vs O(n)")
4. **When does it matter?** - Scale/conditions where impact is significant
5. **What's the fix?** - The efficient alternative

### Example Description

> "Detects string concatenation using + operator inside loops, which creates unnecessary intermediate String objects and degrades performance. For n iterations, this results in O(n²) time complexity instead of O(n) when using StringBuilder. Use StringBuilder.append() for loop concatenations."

---

## Remediation Time Estimates

| Performance Issue | Typical Remediation Time |
|-------------------|-------------------------|
| String concatenation in loop | 10min (convert to StringBuilder) |
| Unnecessary boxing | 10min (use primitives or primitive streams) |
| Inefficient collection usage | 15min (set initial capacity or use correct type) |
| Inefficient loops | 15min (refactor loop structure) |
| N+1 query | 30min (implement eager loading or batch query) |
| Memory leaks | 20min (implement try-with-resources) |
| Synchronous I/O in async | 30min (convert to async alternatives) |

---

## Big-O Complexity Reference

When documenting performance impacts, reference complexity:

| Pattern | Inefficient | Optimized |
|---------|-------------|-----------|
| String concat in loop | O(n²) | O(n) with StringBuilder |
| Nested loop queries | O(n*m) queries | O(1) with JOIN |
| Linear search in loop | O(n*m) | O(n) with HashSet |
| ArrayList random insert | O(n) | O(1) with LinkedList |

---

## Common Performance Anti-Patterns

| Anti-Pattern | Problem | Solution |
|--------------|---------|----------|
| String + in loop | Creates n intermediate objects | Use StringBuilder |
| Query in loop (N+1) | n+1 database roundtrips | Use JOIN or batch fetch |
| Unclosed streams | Memory/handle leaks | Use try-with-resources |
| Boxing in hot path | Unnecessary object allocation | Use primitives |
| Wrong collection type | O(n) vs O(1) operations | Choose appropriate type |
| Blocking in async | Thread starvation | Use async I/O |
| No initial capacity | Multiple array resizes | Set initial capacity |
